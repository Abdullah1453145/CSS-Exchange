# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

<#
.SYNOPSIS
    This script audits mails, calendar and task items and check if PidLidReminderFileParameter property is populated or not.
    If required admins can use this script to cleanup the property for items they find malicious or even delete these items permanently.
.DESCRIPTION
    There are two modes in which we can run the script Audit and Cleanup.

    Audit Mode: Script provides a csv to the admins with details of items that have PidLidReminderFileParameter property populated.
    Cleanup Mode: Script performs Cleanup action on items by either clearing the property or deleting the mail itself.

    Prerequisites to run the script for exchange onprem: You need to have ApplicationImpersonation role

    Prerequisites to run the script for exchange online: You need to be a member of Organization Management.
    The script will create an application with full access permission on all the mailboxes.

    The script uses EWS managed api to make ews calls in order to fetch items from user mailboxes.
    So the machine on which the script is run should be able to make EWS calls to Exchange Server.
.PARAMETER CreateAzureApplication
    Use this switch to create a Azure AD application that can be used for running the script in online mode
.PARAMETER DeleteAzureApplication
    Use this switch to delete the Azure AD application
.PARAMETER UserMailboxesFilePath
    Use this parameter to provide path to the file containing list of UserAddresses to audit
.PARAMETER StartTimeFilter
    Use this parameter to provide start time filter
.PARAMETER EndTimeFilter
    Use this parameter to provide end time filter
.PARAMETER CleanupAction
    Use this parameter to provide type of cleanup action you want to provide (ClearProperty/ClearItem)
.PARAMETER CleanupInfoFilePath
    Use this parameter to provide path to the csv file containing the details of items to be cleaned up
.PARAMETER EWSExchange2013
    Use this switch if you are running on Exchange 2013 server mailboxes
.PARAMETER ScriptUpdateOnly
    This optional parameter allows you to only update the script without performing any other actions.
.PARAMETER SkipVersionCheck
    This optional parameter allows you to skip the automatic version check and script update.
.PARAMETER IgnoreCertificateMismatch
    This optional parameter lets you ignore TLS certificate mismatch errors.
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -CreateAzureApplication
    This will run the tool to create a new Azure application with required permissions
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -UserMailboxFilePath <path to txt file>
    This will run the tool in audit mode on all the users present in the file provided
.EXAMPLE
    PS C:\> .\CVE-2023-23397.ps1 -CleanupAction ClearItem -CleanupInfoFilePath <path to csv file>
    This will run the tool in clean up mode and clear all the items mentioned in the csv file
#>
[CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]

param(
    [Parameter(Mandatory=$true, ParameterSetName="CreateAzureApplication")]
    [Switch]$CreateAzureApplication,

    [Parameter(Mandatory=$true, ParameterSetName="DeleteAzureApplication")]
    [Switch]$DeleteAzureApplication,

    [ValidateScript({ Test-Path $_ })]
    [Parameter(Mandatory=$true, ParameterSetName="Audit")]
    [String]$UserMailboxesFilePath,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [DateTime]$StartTimeFilter,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [DateTime]$EndTimeFilter,

    [ValidateSet("ClearProperty", "ClearItem")]
    [Parameter(Mandatory=$true, ParameterSetName="Cleanup")]
    [string]$CleanupAction,

    [ValidateScript({ Test-Path -Path $_ -PathType leaf })]
    [Parameter(Mandatory=$true, ParameterSetName="Cleanup")]
    [string]$CleanupInfoFilePath,

    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [switch]$EWSExchange2013,

    [Parameter(Mandatory=$true, ParameterSetName="ScriptUpdateOnly")]
    [switch]$ScriptUpdateOnly,

    [Parameter(Mandatory=$false, ParameterSetName="CreateAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="DeleteAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [switch]$SkipVersionCheck,

    [Parameter(Mandatory=$false, ParameterSetName="CreateAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="DeleteAzureApplication")]
    [Parameter(Mandatory=$false, ParameterSetName="Audit")]
    [Parameter(Mandatory=$false, ParameterSetName="Cleanup")]
    [switch]$IgnoreCertificateMismatch
)

begin {
    $BuildVersion = ""

    . $PSScriptRoot\WriteFunctions.ps1
    . $PSScriptRoot\..\..\..\Shared\OutputOverrides\Write-Host.ps1
    . $PSScriptRoot\..\..\..\Shared\OutputOverrides\Write-Verbose.ps1
    . $PSScriptRoot\..\..\..\Shared\OutputOverrides\Write-Warning.ps1
    . $PSScriptRoot\..\..\..\Shared\ScriptUpdateFunctions\Test-ScriptVersion.ps1
    . $PSScriptRoot\..\..\..\Shared\Get-NuGetPackage.ps1
    . $PSScriptRoot\..\..\..\Shared\Invoke-ExtractArchive.ps1
    . $PSScriptRoot\..\..\..\Shared\LoggerFunctions.ps1
    . $PSScriptRoot\..\..\..\Shared\Show-Disclaimer.ps1

    $Script:Logger = Get-NewLoggerInstance -LogName "CVE-2023-23397-$((Get-Date).ToString("yyyyMMddhhmmss"))-Debug" `
        -AppendDateTimeToFileName $false `
        -ErrorAction SilentlyContinue

    SetWriteHostAction ${Function:Write-HostLog}
    SetWriteVerboseAction ${Function:Write-VerboseLog}
    SetWriteWarningAction ${Function:Write-HostLog}

    $mode = $PsCmdlet.ParameterSetName

    ## function to read the config file and get the configuration values
    function ReadConfigurationFile {
        ## the script expects the configuration file in the same location as the script with the name <ScriptName>.config
        $ConfigFileName = "CVE-2023-23397.config"
        $ConfigFilePath = "$PSScriptRoot\$ConfigFileName"

        Write-Host "Reading configurations from $ConfigFilePath ..."
        try {
            $RawConfigurations = (Get-Content $ConfigFilePath).Split([Environment]::NewLine) | Where-Object { $_ -ne "" -and $null -ne $_ }
        } catch {
            Write-Error "Unable to Read configuration file. Please make sure the configuration file is present at the same directory as the script and named $ConfigFileName"
            exit
        }

        $ConfigurationMap = @{}

        foreach ($RawConfiguration in $RawConfigurations) {
            $ConfigurationMap[($RawConfiguration.Split(":", 2)[0])] = $RawConfiguration.Split(":", 2)[1]
        }

        Write-Host "successfully read configurations from $ConfigFilePath ..." -ForegroundColor Green
        return $ConfigurationMap
    }

    ## function to test if the configurations provided are valid
    function TestConfigurations {
        param (
            $Configurations
        )

        Write-Host "Validating configurations provided ..."

        if ($CreateAzureApplication -or $DeleteAzureApplication) {
            if ([System.String]::IsNullOrEmpty($Configurations["AzureEnvironmentName"])) {
                Write-Error "Please provide a valid value for AzureEnvironmentName in the configuration."
                exit
            }

            if ([System.String]::IsNullOrEmpty($Configurations["AzureApplicationName"])) {
                Write-Error "Please provide a valid value for AzureApplicationName in the configuration."
                exit
            }
            return
        }

        $DLLPath = $Configurations["DLLPath"]

        ## if DLL Path is mentioned is it valid
        if (-not [System.String]::IsNullOrEmpty($DLLPath)) {
            if (-not (Test-Path $DLLPath)) {
                Write-Error "The DLL path provided in the configuration file is not valid."
                exit
            }
        }

        ## MaxCSVLength is required and should be a valid integer
        try {
            $MaxCSVLength = [int]$Configurations["MaxCSVLength"]
        } catch {
            Write-Error "The value of MaxCSVLength provided should be a valid integer greater than 0."
            exit
        }

        if ($MaxCSVLength -le 0) {
            Write-Error "The value of MaxCSVLength provided should be a valid integer greater than 0."
            exit
        }

        ## Environment is required and should be valid
        $Environment = $Configurations["Environment"]
        if (-not ($Environment -eq "Onprem" -or $Environment -eq "Online")) {
            Write-Error "The value of Environment should be either Onprem or Online."
            exit
        }

        ## Validations when environment is online
        if ($Environment -eq "Online") {
            if ([System.String]::IsNullOrEmpty($Configurations["AzureApplicationName"])) {
                Write-Error "Please provide a valid value for AzureApplicationName in the configuration."
                exit
            }

            if ([System.String]::IsNullOrEmpty($Configurations["AzureEnvironmentName"])) {
                Write-Error "Please provide a valid value for AzureEnvironmentName in the configuration."
                exit
            }

            if ([System.String]::IsNullOrEmpty($Configurations["EWSOnlineURL"])) {
                Write-Error "Please provide a valid EWSOnlineURL for EWS request"
                exit
            }

            if ([System.String]::IsNullOrEmpty($Configurations["AzureADEndpoint"])) {
                Write-Error "Please provide a valid AzureADEndpoint for EWS request"
                exit
            }

            if ([System.String]::IsNullOrEmpty($Configurations["EWSOnlineScope"])) {
                Write-Error "Please provide a valid EWSOnlineScope for EWS request"
                exit
            }
        }

        Write-Host "Validated configurations successfully ..." -ForegroundColor Green
    }

    ## function to create ews managed api service object
    function EWSAuth {
        param(
            [string]$Environment,
            $token,
            $EWSOnlineURL,
            $EWSServerURL
        )
        ## Create the Exchange Service object with credentials
        if ($EWSExchange2013) {
            $Service = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService([Microsoft.Exchange.WebServices.Data.ExchangeVersion]::Exchange2013)
        } else {
            $Service = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService([Microsoft.Exchange.WebServices.Data.ExchangeVersion]::Exchange2016)
        }

        if ($Environment -eq "Onprem") {
            $PSCredential = (Get-Credential)
            $Service.Credentials = New-Object Microsoft.Exchange.WebServices.Data.WebCredentials($PSCredential.UserName, [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($PSCredential.Password)))
        } else {
            $Service.Credentials = New-Object Microsoft.Exchange.WebServices.Data.OAuthCredentials($token.access_token)
        }

        if ($Environment -eq "Onprem") {
            if ($null -ne $EWSServerURL -and $EWSServerURL -ne "") {
                $Service.Url = New-Object Uri($EWSServerURL)
                CheckOnpremCredentials -ewsService $Service
            } else {
                try {
                    $Service.AutodiscoverUrl($PSCredential.UserName)
                } catch {
                    Write-Error "Unable to make Autodiscover call to fetch EWS endpoint details. Please make sure you have enter valid credentials."
                    exit
                }
            }
        } else {
            $Service.Url = $EWSOnlineURL
        }

        return $Service
    }

    ## function to validate onprem credential
    function CheckOnpremCredentials {
        param (
            $ewsService
        )

        try {
            $null = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, [Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot)
        } catch {
            Write-Error "Invalid credentials. Please check your username and password and try again."
            exit
        }
    }

    ## function to convert array of email addresses to string
    function Get-MultiValueEmailString([array]$emailArray) {
        if ($emailArray.Length -gt 0) {

            $tempArray = @()
            foreach ($value in $emailArray) {
                $tempArray += $value.Address
            }
            $valueList = $tempArray -join ","

            return $valueList
        } else {
            return $null
        }
    }

    ## function to add a row to the csv
    function CreateCustomCSV {
        param (
            $mailbox,
            $data,
            [string]$CsvPath
        )

        $ItemType = $data.ItemClass

        if ($data.ItemClass.StartsWith("IPM.Note")) {
            $ItemType = "E-Mail"
        } elseif ($data.ItemClass.StartsWith("IPM.Appointment")) {
            $ItemType = "Calendar"
        } elseif ($data.ItemClass.StartsWith("IPM.Task")) {
            $ItemType = "Task"
        }

        $row = [PSCustomObject]@{
            "Mailbox"                     = $mailbox
            "Id"                          = $data.Id
            "ItemType"                    = $ItemType
            "Sender"                      = Get-MultiValueEmailString($data.From)
            "Recipient"                   = Get-MultiValueEmailString($data.ToRecipients)
            "Subject"                     = $data.Subject
            "DateReceived"                = $data.DateTimeReceived
            "PidLidReminderFileParameter" = $data.ExtendedProperties[0].Value
            "Cleanup"                     = "N"
        }

        $row | Export-Csv -Path $CsvPath -NoTypeInformation -Append -Encoding utf8 -Force
    }

    # Define a function to get all the SubFolders of a given folder
    function GetSubFolders {
        param (
            $folder,
            $foldersList
        )
        # Get the SubFolders of the folder
        $folderView = New-Object Microsoft.Exchange.WebServices.Data.FolderView(1000)
        $folder.FindFolders($folderView) | ForEach-Object {
            # Add the folder path to the list
            $null = $foldersList.Add($_)
            # Recursively get the SubFolders of this folder
            GetSubFolders -folder $_ -foldersList $foldersList
        }
    }

    ## function to find item on bases of store ID
    function FindItem {
        param (
            [Microsoft.Exchange.WebServices.Data.ExchangeService]$exchangeService,
            [string]$Id
        )
        $ps = New-Object Microsoft.Exchange.WebServices.Data.PropertySet(New-Object Microsoft.Exchange.WebServices.Data.ExtendedPropertyDefinition([Microsoft.Exchange.WebServices.Data.DefaultExtendedPropertySet]::Common, 0x0000851F, [Microsoft.Exchange.WebServices.Data.MapiPropertyType]::String))
        return [Microsoft.Exchange.WebServices.Data.Item]::Bind($exchangeService, $Id, $ps);
    }

    ## function to create OAuth token
    function CreateOAUTHToken {
        param (
            [string]$TenantID,
            [string]$ClientID,
            [string]$AppSecret,
            [string]$AzureADEndpoint,
            [string]$Scope
        )

        try {
            $body=@{
                scope         =$Scope
                client_id     =$ClientID
                client_secret =$AppSecret
                grant_type    ="client_credentials"
            }

            $PostSplat = @{
                ContentType = 'application/x-www-form-urlencoded'
                Method      = 'POST'

                # Create string by joining bodyList with '&'
                Body        = $body
                Uri         = "$AzureADEndpoint$TenantID/oauth2/v2.0/token"
            }

            $Token = Invoke-RestMethod @PostSplat
        } catch {
            Write-Host "`nFailure creating EWS auth token, exiting Program. Please review the error message below and re-run the program:`n`n$_" -ForegroundColor Red
            exit
        }

        $script:tokenLastRefreshTime = (Get-Date)

        return $Token
    }

    ## function that create an App secret to for a given application and return it
    function GetApplicationDetails {
        param (
            $AzureApplicationName,
            $AzureEnvironmentName
        )

        try {
            Import-Module AzureAD
            Write-Host "`nPrompting user for authentication, please minimize this window if you do not see an authorization prompt as it may be in the background"
            Connect-AzureAD -AzureEnvironmentName $AzureEnvironmentName
        } catch {
            Write-Host "Unable to run Connect-AzureAD... Make sure you have AzureAD module installed and you have provided a valid Azure Environment in the configuration" -ForegroundColor Red
            exit
        }

        try {
            $aadApplication = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"
        } catch {
            Write-Error "No Azure Application found with the name $AzureApplicationName. Please re-run the script with -CreateAzureApplication to create the application."
            exit
        }

        if ($null -eq $aadApplication) {
            Write-Error "No Azure Application found with the name $AzureApplicationName. Please re-run the script with -CreateAzureApplication to create the application."
            exit
        }

        #Assign App Password, make it valid for 7 days
        $appPassword = New-AzureADApplicationPasswordCredential -ObjectId $aadApplication.ObjectId -CustomKeyIdentifier "AppAccessKey" -EndDate (Get-Date).AddDays(7)

        Write-Host "`nWaiting 60 seconds for app credentials to register.."
        Start-Sleep -Seconds 60
        Write-Host "`nContinuing..."

        return @{
            "TenantID"  = (Get-AzureADTenantDetail).ObjectId
            "ClientID"  = $aadApplication.AppId
            "AppSecret" = $appPassword.Value
        }
    }

    ## function to delete Azure AD application
    function DeleteApplication {
        param (
            $AzureEnvironmentName,
            $AzureApplicationName
        )

        try {
            Import-Module AzureAD
            Write-Host "`nPrompting user for authentication, please minimize this window if you do not see an authorization prompt as it may be in the background"
            Connect-AzureAD -AzureEnvironmentName $AzureEnvironmentName
        } catch {
            Write-Host "Unable to run Connect-AzureAD... Make sure you have AzureAD module installed and you have provided a valid Azure Environment in the configuration" -ForegroundColor Red
            exit
        }

        try {
            $app = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"

            if ($null -eq $app) {
                Write-Host "No application with name $AzureApplicationName found" -ForegroundColor Red
                exit
            }

            Remove-AzureADApplication -ObjectId $app.ObjectId

            if (Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'") {
                Write-Error "Unable to delete the Azure AD application. Please try again or delete it manually."
                exit
            }
        } catch {
            Write-Error "Unable to delete the Azure AD application. Please try again or delete it manually."
            exit
        }

        Write-Host "Successfully deleted the application $AzureApplicationName" -ForegroundColor Green
    }

    ## function to create Azure AD application
    function CreateApplication {
        param(
            $AzureEnvironmentName,
            $AzureApplicationName
        )

        try {
            Import-Module AzureAD
            Write-Host "`nPrompting user for authentication, please minimize this window if you do not see an authorization prompt as it may be in the background"
            Connect-AzureAD -AzureEnvironmentName $AzureEnvironmentName
        } catch {
            Write-Host "Unable to run Connect-AzureAD... Make sure you have AzureAD module installed and you have provided a valid Azure Environment in the configuration" -ForegroundColor Red
            exit
        }

        $aadApplication = Get-AzureADApplication -Filter "DisplayName eq '$AzureApplicationName'"

        if ($null -ne $aadApplication) {
            Write-Host "Application with name $AzureApplicationName already exists..."
            Write-Host "Client ID: $($aadApplication.AppId)" -ForegroundColor Green
            exit
        }

        ## Creating application with default name
        [string]$appName = $AzureApplicationName

        try {
            $aadApplication = New-AzureADApplication -DisplayName $appName
        } catch {
            Write-Host "`nThere was an error creating the application, please reference the error below and try again" -ForegroundColor Red
            exit
        }

        #Add current user to owner of newly created application
        $currentUser = (Get-AzureADUser -ObjectId (Get-AzureADCurrentSessionInfo).Account.Id)
        Write-Host "`nAdding user $($currentUser.UserPrincipalName) as owner of $appName"
        Add-AzureADApplicationOwner -ObjectId $aadApplication.ObjectId -RefObjectId $currentUser.ObjectId | Out-Null

        #Get Service Principal of MS Graph Resource API
        $ews_SP = Get-AzureADServicePrincipal -All $true | Where-Object { $_.DisplayName -eq "Office 365 Exchange Online" }

        #Initialize RequiredResourceAccess for Microsoft Graph Resource API
        $requiredAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess
        $requiredAccess.ResourceAppId = $ews_SP.AppId
        $requiredAccess.ResourceAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.ResourceAccess]

        #Set Application Permissions
        $ApplicationPermissions = @('full_access_as_app')

        #Add app permissions
        foreach ($permission in $ApplicationPermissions) {
            $reqPermission = $null
            #Get required app permission
            $reqPermission = $ews_SP.AppRoles | Where-Object { $_.Value -eq $permission }
            if ($reqPermission) {
                $resourceAccess = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess
                $resourceAccess.Type = "Role"
                $resourceAccess.Id = $reqPermission.Id
                #Add required app permission
                $requiredAccess.ResourceAccess.Add($resourceAccess)
            } else {
                Write-Host "App permission $permission not found in the Graph Resource API" -ForegroundColor Red
            }
        }

        #Add required resource accesses
        $requiredResourcesAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.RequiredResourceAccess]
        $requiredResourcesAccess.Add($requiredAccess)

        #Set permissions in newly created Azure AD App
        $appObjectId=$aadApplication.ObjectId
        Write-Host "`nSetting Azure AD Permissions"
        Set-AzureADApplication -ObjectId $appObjectId -RequiredResourceAccess $requiredResourcesAccess | Out-Null

        #Create Service Principal
        $appId=$aadApplication.AppId
        $servicePrincipal = New-AzureADServicePrincipal -AppId $appId -Tags @("WindowsAzureActiveDirectoryIntegratedApp")

        #Grant Admin Consent for App Permissions
        $requiredResourcesAccess=(Get-AzureADApplication -ObjectId $appObjectId).RequiredResourceAccess

        Write-Host "`nAssigning Necessary Azure AD Service Roles"
        foreach ($resourceAppAccess in $requiredResourcesAccess) {
            $resourceApp = Get-AzureADServicePrincipal -All $true | Where-Object { $_.AppId -eq $resourceAppAccess.ResourceAppId }

            foreach ($permission in $resourceAppAccess.ResourceAccess) {
                if ($permission.Type -eq "Role") {
                    New-AzureADServiceAppRoleAssignment -ObjectId $servicePrincipal.ObjectId -PrincipalId $servicePrincipal.ObjectId -ResourceId $resourceApp.ObjectId -Id $permission.Id | Out-Null
                }
            }
        }

        #Use newly created app to query graphAPI
        [string]$ClientID = $aadApplication.AppId

        Write-Host "Application created with required permissions. Client ID: $ClientID" -ForegroundColor Green
    }

    ## function to check if a given token is expired and renew it
    function CheckTokenExpiry {
        param (
            $applicationInfo,
            [ref]$ewsService,
            [ref]$token,
            [string]$Environment,
            $EWSOnlineURL,
            $EWSOnlineScope,
            $AzureADEndpoint
        )

        if ($Environment -eq "Onprem") {
            return
        }

        # if token is going to expire in next 5 min then refresh it
        if ($null -eq $script:tokenLastRefreshTime -or $script:tokenLastRefreshTime.AddMinutes(55) -lt (Get-Date)) {
            $token.Value = CreateOAUTHToken -TenantID $applicationInfo.TenantID -ClientID $applicationInfo.ClientID -AppSecret $applicationInfo.AppSecret -AzureADEndpoint $AzureADEndpoint -Scope $EWSOnlineScope
            $ewsService.Value = EWSAuth -Environment $Environment -token $token.Value -EWSOnlineURL $EWSOnlineURL
        }
    }

    $trustAllCertsPolicyClass = @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
    Add-Type -TypeDefinition $trustAllCertsPolicyClass -ErrorAction Stop
} process {
    Write-Host ("CVE-2023-23397 script version $($BuildVersion)") -ForegroundColor Green

    if ($ScriptUpdateOnly) {
        switch (Test-ScriptVersion -AutoUpdate -Confirm:$false) {
            ($true) { Write-Host ("Script was successfully updated") -ForegroundColor Green }
            ($false) { Write-Host ("No update of the script performed") -ForegroundColor Yellow }
            default { Write-Host ("Unable to perform ScriptUpdateOnly operation") -ForegroundColor Red }
        }
        return
    }

    if ((-not($SkipVersionCheck)) -and
        (Test-ScriptVersion -AutoUpdate -Confirm:$false)) {
        Write-Host ("Script was updated. Please rerun the command") -ForegroundColor Yellow
        return
    }

    if ($IgnoreCertificateMismatch) {
        Write-Verbose ("IgnoreCertificateMismatch was used -policy will be set to: TrustAllCertsPolicy")
        [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    }

    ## Reading configuration file
    $Configurations = ReadConfigurationFile

    ## Test if configurations provided are valid
    TestConfigurations -Configurations $Configurations

    ## CreateApplicationMode or DeleteApplicationMode
    if ($CreateAzureApplication -or $DeleteAzureApplication) {
        $AzureEnvironmentName = $Configurations["AzureEnvironmentName"]
        $AzureApplicationName = $Configurations["AzureApplicationName"]
        if ($CreateAzureApplication) {
            $null = CreateApplication -AzureEnvironmentName $AzureEnvironmentName -AzureApplicationName $AzureApplicationName
            exit
        }

        $null = DeleteApplication -AzureEnvironmentName $AzureEnvironmentName -AzureApplicationName $AzureApplicationName
        exit
    }

    ## Extracting configurations
    $Environment = $Configurations["Environment"]
    $MaxCSVLength = $Configurations["MaxCSVLength"]

    if ($Environment -eq "Online") {
        Write-Host "The script is running for Exchange Online" -Foreground Green
        $AzureEnvironmentName = $Configurations["AzureEnvironmentName"]
        $EWSOnlineURL = $Configurations["EWSOnlineURL"]
        $EWSOnlineScope = $Configurations["EWSOnlineScope"]
        $AzureApplicationName = $Configurations["AzureApplicationName"]
        $AzureADEndpoint = $Configurations["AzureADEndpoint"]
    } else {
        Write-Host "The script is running for Exchange Onprem" -Foreground Green
        $EWSServerURL = $Configurations["EwsServerURL"]
    }

    ## Importing Microsoft.Exchange.WebServices.dll
    $DLLPath = $Configurations["DLLPath"]

    if ([System.String]::IsNullOrEmpty($DLLPath)) {
        Write-Host "Trying to find Microsoft.Exchange.WebServices.dll in the script folder"
        $DLLPath = (Get-ChildItem -Path "$PSScriptRoot\EWS" -Recurse -Filter "Microsoft.Exchange.WebServices.dll" |
                Select-Object -First 1).FullName

        if ([System.String]::IsNullOrEmpty($DLLPath)) {
            Write-Host "Microsoft.Exchange.WebServices.dll wasn't found - attempting to download it from the internet" -ForegroundColor Yellow
            $nuGetPackage = Get-NuGetPackage -PackageId "Microsoft.Exchange.WebServices" -Author "Microsoft"

            if ($nuGetPackage.DownloadSuccessful) {
                $unzipNuGetPackage = Invoke-ExtractArchive -CompressedFilePath $nuGetPackage.NuGetPackageFullPath -TargetFolder "$PSScriptRoot\EWS"

                if ($unzipNuGetPackage.DecompressionSuccessful) {
                    $DLLPath = (Get-ChildItem -Path $unzipNuGetPackage.FullPathToDecompressedFiles -Recurse -Filter "Microsoft.Exchange.WebServices.dll" |
                            Select-Object -First 1).FullName
                } else {
                    Write-Host "Failed to unzip Microsoft.Exchange.WebServices.dll. Please unzip the package manually." -ForegroundColor Red
                    exit
                }
            } else {
                Write-Host "Failed to download Microsoft.Exchange.WebServices.dll from the internet. Please download the package manually and extract the dll. Provide the path to dll in the configuration file." -ForegroundColor Red
                exit
            }
        } else {
            Write-Host "Microsoft.Exchange.WebServices.dll was found in the script folder" -ForegroundColor Green
        }
    }

    try {
        Import-Module -Name $DLLPath -ErrorAction Stop
    } catch {
        Write-Host "Failed to import Microsoft.Exchange.WebServices.dll" -ForegroundColor Red
        exit
    }

    $failedMailboxes = New-Object 'System.Collections.Generic.List[string]'
    $invalidEntries = New-Object 'System.Collections.Generic.List[string]'

    #MailInfo
    $mailInfo = @{
        "Id"                          = [Microsoft.Exchange.WebServices.Data.ItemSchema]::Id
        "Sender"                      = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::From
        "Recipient"                   = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::ToRecipients
        "Subject"                     = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::Subject
        "DateReceived"                = [Microsoft.Exchange.WebServices.Data.EmailMessageSchema]::DateTimeReceived
        "PidLidReminderFileParameter" = New-Object Microsoft.Exchange.WebServices.Data.ExtendedPropertyDefinition([Microsoft.Exchange.WebServices.Data.DefaultExtendedPropertySet]::Common, 0x0000851F, [Microsoft.Exchange.WebServices.Data.MapiPropertyType]::String)
        "ItemClass"                   = [Microsoft.Exchange.WebServices.Data.ItemSchema]::ItemClass
    }

    if ($Environment -eq "Online") {
        $application = GetApplicationDetails -AzureApplicationName $AzureApplicationName -AzureEnvironmentName $AzureEnvironmentName

        $applicationInfo = @{
            "TenantID"  = $application.Tenant.Id
            "ClientID"  = $application.ClientID
            "AppSecret" = $application.AppSecret
        }

        #Create OAUTH token
        $EWSToken = CreateOAUTHToken -TenantID $applicationInfo.TenantID -ClientID $applicationInfo.ClientID -AppSecret $applicationInfo.AppSecret -Scope $EWSOnlineScope -AzureADEndpoint $AzureADEndpoint

        $ewsService = EWSAuth -Environment $Environment -Token $EWSToken -EWSServerURL $EWSServerURL -EWSOnlineURL $EWSOnlineURL
    } else {
        #Server
        $EWSToken = $null
        $ewsService = EWSAuth -Environment $Environment -EWSServerURL $EWSServerURL
    }

    if ($PSCmdlet.ParameterSetName -eq "Audit") {
        $mailAddresses = (Get-Content $UserMailboxesFilePath).Split([Environment]::NewLine) | Where-Object { $_ -ne "" -and $null -ne $_ }

        if ($null -eq $mailAddresses -or $mailAddresses.Count -eq 0) {
            Write-Error "No mailbox provided in the file"
            exit
        }

        $csvFileName = ("AuditResults_$(Get-Date -Format "yyyyMMdd_HHmmss").csv")

        $itemView = New-Object Microsoft.Exchange.WebServices.Data.ItemView([int]::MaxValue)

        $searchFilterCollection = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+SearchFilterCollection

        if ($null -ne $StartTimeFilter) {
            $searchFilterStartTime = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsGreaterThan([Microsoft.Exchange.WebServices.Data.ItemSchema]::DateTimeCreated, $StartTimeFilter)
            $searchFilterCollection.Add($searchFilterStartTime)
        }

        if ($null -ne $EndTimeFilter) {
            $searchFilterEndTime = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+IsLessThan([Microsoft.Exchange.WebServices.Data.ItemSchema]::DateTimeCreated, $EndTimeFilter)
            $searchFilterCollection.Add($searchFilterEndTime)
        }

        $searchFilterPidLidReminderFileParameterExists = New-Object Microsoft.Exchange.WebServices.Data.SearchFilter+Exists($mailInfo["PidLidReminderFileParameter"])
        $searchFilterCollection.Add($searchFilterPidLidReminderFileParameterExists)

        $PropertySet = New-Object Microsoft.Exchange.WebServices.Data.PropertySet
        foreach ($key in $mailInfo.Keys) {
            $PropertySet.Add($mailInfo[$key])
        }

        $mailboxProcessed = 0
        $rowCount = 0

        foreach ($mailAddress in $mailAddresses) {
            Write-Host ("Scanning $($mailboxProcessed + 1) of $($mailAddresses.Count) mailboxes (currently: $mailAddress)")

            $userMailbox = New-Object Microsoft.Exchange.WebServices.Data.Mailbox($mailAddress)

            if ($null -eq $userMailbox) {
                Write-Host ("Unable to get mailbox associated with mail address $mailAddress")
                $failedMailboxes.Add($mailAddress)
                $mailboxProcessed += 1
                continue
            }

            try {
                # Check for token expiry
                CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope
                $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)

                $rootFolderId = New-Object Microsoft.Exchange.WebServices.Data.FolderId([Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::MsgFolderRoot, $userMailbox)
                $rootFolder = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($ewsService, $rootFolderId)

                # Create a new ArrayList to hold the folder
                $foldersList = New-Object System.Collections.ArrayList

                GetSubFolders -folder $rootFolder -foldersList $foldersList
            } catch {
                Write-Host ("Unable to process mailbox $mailAddress, Either you don't have proper impersonation rights or the mailbox is inaccessible. Inner Exception:`n`n$_")
                $failedMailboxes.Add($mailAddress)
                $mailboxProcessed += 1
                continue
            }

            $IdsProcessed = New-Object 'System.Collections.Generic.List[string]'

            foreach ($folder in $foldersList) {
                try {
                    # Check for token expiry
                    CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo -EWSOnlineURL $EWSOnlineURL -EWSOnlineScope $EWSOnlineScope
                    $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $mailAddress)
                    $results = $ewsService.FindItems($folder.Id, $searchFilterCollection, $itemView)
                    if ($null -ne $results -and $null -ne $results.Items -and $results.Items.Count -gt 0) {
                        $items = $ewsService.LoadPropertiesForItems($results.Items, $PropertySet)
                    } else {
                        continue
                    }

                    foreach ($item in $items) {
                        if ($item.Item.Id -notin $IdsProcessed) {
                            CreateCustomCSV -mailbox $mailAddress -data $item.Item -CsvPath $csvFileName
                            $rowCount ++
                            if ($rowCount -ge $MaxCSVLength) {
                                Write-Host ("The csv file has reached it's maximum limit of $MaxCSVLength rows... aborting... Please apply appropriate filters to reduce the result size")
                                Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
                                exit
                            }
                            $IdsProcessed.Add($item.Item.Id)
                        }
                    }
                } catch {
                    Write-Host "Error while scanning $($folder.DisplayName) of the mailbox $mailAddress. Inner Exception:`n`n$_" -ForegroundColor Red
                }
            }

            $mailboxProcessed ++;
        }

        if ($rowCount -eq 0) {
            Write-Host "No vulnerable item found"
        } else {
            Write-Host ("Please find the audit results in $csvFileName created in the current folder.")
        }
    } else {
        $params = @{
            Message   = "Display Warning about Store operation"
            Target    = "The script will perform store operation on mailboxes using EWS"
            Operation = ""
        }

        if ($CleanupAction -eq "ClearProperty") {
            $params.Operation = "Clear the PidLidReminderFileParameter property of mail items"
        }

        if ($CleanupAction -eq "ClearItem") {
            $params.Operation = "Delete items"
        }

        Show-Disclaimer @params

        $cleanupCSV = (Import-Csv $CleanupInfoFilePath)

        $entryCount = 0

        foreach ($entry in $cleanupCSV) {
            $entryCount ++
            if ($null -eq $entry.Id -or $entry.Id -eq "") {
                Write-Error ("No Id present for entry number: $entryCount, Line number: $($entryCount + 1)")
                $invalidEntries.Add($entryCount)
                continue
            }

            if ($null -eq $entry.Mailbox -or $entry.Mailbox -eq "") {
                Write-Error ("No Mailbox address present for entry number: $entryCount, Line number: $($entryCount + 1)")
                $invalidEntries.Add($entryCount)
                continue
            }

            if ($null -ne $entry.Cleanup -and $entry.Cleanup.ToLower() -eq "y") {
                # Check for token expiry
                CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo
                $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $entry.Mailbox)
                $item = FindItem -exchangeService $ewsService -Id $entry.Id
                if ($null -ne $item) {
                    try {
                        if ($CleanupAction -eq "ClearItem") {
                            $item.Delete([Microsoft.Exchange.WebServices.Data.DeleteMode]::HardDelete)
                        } else {
                            if (-not $item.RemoveExtendedProperty($mailInfo["PidLidReminderFileParameter"])) {
                                Write-Error ("Failed to clear property for entry number: $entryCount, Line number: $($entryCount + 1)")
                                $invalidEntries.Add($entryCount)
                                continue
                            }

                            CheckTokenExpiry -Environment $Environment -token ([ref]$EWSToken) -ewsService ([ref]$ewsService) -applicationInfo $applicationInfo
                            $ewsService.ImpersonatedUserId = New-Object Microsoft.Exchange.WebServices.Data.ImpersonatedUserId([Microsoft.Exchange.WebServices.Data.ConnectingIdType]::SmtpAddress, $entry.Mailbox)
                            $item.Update([Microsoft.Exchange.WebServices.Data.ConflictResolutionMode]::AlwaysOverwrite);
                        }
                    } catch {
                        Write-Error ("Unable to perform cleanup action on entry number: $entryCount, Line number: $($entryCount + 1)")
                        $invalidEntries.Add($entryCount)
                        continue
                    }
                } else {
                    Write-Error ("Unable to find item associated to entry number: $entryCount, Line number: $($entryCount + 1)")
                    $invalidEntries.Add($entryCount)
                    continue
                }
            }
        }

        Write-Host "Completed cleanup operation!"
    }
} end {
    if ($mode -eq "Audit" -and $null -ne $failedMailboxes -and $failedMailboxes.Count -gt 0) {
        Write-Host ("Couldn't Audit mailboxes: {0}" -f [string]::Join(", ", $failedMailboxes))
    }

    if ($mode -eq "Cleanup" -and $null -ne $invalidEntries -and $invalidEntries.Count -gt 0) {
        Write-Host ("Couldn't Cleanup the entries: {0}" -f [string]::Join(", ", $invalidEntries))
    }

    Remove-Module -Name "Microsoft.Exchange.WebServices" -ErrorAction SilentlyContinue
}
