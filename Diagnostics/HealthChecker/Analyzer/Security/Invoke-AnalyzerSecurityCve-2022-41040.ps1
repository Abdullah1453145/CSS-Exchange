# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

. $PSScriptRoot\..\Add-AnalyzedResultInformation.ps1
. $PSScriptRoot\..\..\..\..\Shared\ErrorMonitorFunctions.ps1
function Invoke-AnalyzerSecurityCve-2022-41040 {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ref]$AnalyzeResults,

        [Parameter(Mandatory = $true)]
        [object]$SecurityObject,

        [Parameter(Mandatory = $true)]
        [object]$DisplayGroupingKey
    )
    # Description: Check for CVE-2022-41040 vulnerability
    # Affected Exchange versions: 2013, 2016, 2019
    # Fix: N/A
    # Mitigation: URL Rewrite set on the Default Web Site virtual directory web.config file only.

    Write-Verbose "Calling: $($MyInvocation.MyCommand)"
    $details = $null

    if ($SecurityObject.ServerRole -ne [HealthChecker.ExchangeServerRole]::Edge) {
        Write-Verbose "Testing CVE: CVE-2022-41040"
        $verifyPattern = "(?=.*autodiscover)(?=.*powershell)"
        $foundSecureRuleDefaultWebSite = $false
        $anyClearSetOnHttpProxy = $false
        $failedToConvertList = @()
        $clearSetOnList = @()
        $iisRewriteRules = $SecurityObject.ExchangeInformation.IISSettings.IISConfigurationSettings |
            Where-Object {
                try {
                    $location = $_.Location
                    $null -ne ([xml]$_.Content).configuration.'system.webServer'.rewrite.rules
                } catch {
                    Write-Verbose "Failed to convert $location to XML"
                    $failedToConvertList += $location
                    Invoke-CatchActions
                }
            }

        if ($null -ne $iisRewriteRules) {
            foreach ($config in $iisRewriteRules) {
                $defaultWebSite = $config.Location -like "*\wwwroot\web.config"
                $rules = ([xml]$config.Content).configuration.'system.webServer'.rewrite.rules
                # If we determine clear was set on AutoD, then any rules in Default Web Site can't be applied
                if ($config.Location -like "*\HttpProxy\*") {
                    $clearBeenSet = $null -ne $rules.clear
                    Write-Verbose "Location: $($config.Location) has clear set: $clearBeenSet"

                    if ($clearBeenSet) {
                        $anyClearSetOnHttpProxy = $true
                        $clearSetOnList += $config.Location
                    }
                }

                foreach ($rule in $rules.rule) {
                    if ($defaultWebSite -and $rule.conditions.add.pattern -eq $verifyPattern) {
                        # Custom Response or AbortRequest should both work to prevent the security hole
                        # Input must be {UrlDecode:{REQUEST_URI}}
                        # match type must be pattern
                        # stop processing should be set otherwise, more logic would need to be in place. If only 1 rule, then we are fine
                        # pattern is always going to be set if found. If foundSecureRule isn't set, then something is wrong with the config
                        Write-Verbose "Found valid pattern for mitigation"
                        $validAction = $rule.action.type -eq "AbortRequest" -or
                        $rule.action.type -eq "CustomResponse"
                        $validConditionsInput = $rule.conditions.add.input -eq "{UrlDecode:{REQUEST_URI}}"
                        $validPatternSyntax = $rule.patternSyntax -ne "Wildcard"
                        $validMatchUrl = $rule.match.url -eq ".*"
                        $stopProcessing = $rule.stopProcessing -eq "true" -or $rules.rule.count -eq 1
                        $enabledRule = $rule.enabled -eq "true" -or $null -eq $rule.enabled

                        if ($validAction -and $validConditionsInput -and $validPatternSyntax -and
                            $validMatchUrl -and $stopProcessing -and $enabledRule) {
                            Write-Verbose "Found a valid rule for mitigation"
                            $foundSecureRuleDefaultWebSite = $true
                        } else {
                            Write-Verbose "Rule didn't meet all the criteria for secure rule"
                        }
                    }
                }
            }
        } else {
            Write-Verbose "No rewrite rules were found on the server"
        }

        if ($foundSecureRuleDefaultWebSite -and $anyClearSetOnHttpProxy) {
            $details = "CVE-2022-41040`r`n`t`tRule is present on Default Web Site, however, the following configuration files are ignoring the rule. $([string]::Join("," ,$clearSetOnList)).`r`n`t`tSelect 'Revert to Parent' in URL Rewrite of IIS Manager to address this."
        } elseif (-not $foundSecureRuleDefaultWebSite) {
            $details = "CVE-2022-41040`r`n`t`tPlease run the EOMTv2 script from: https://aka.ms/EOMTv2"
        } elseif ($failedToConvertList.Count -gt 0) {
            $details = "CVE-2022-41040`r`n`t`tUnknown - Failed to determine the configuration of the following files when trying to convert to XML type: $([string]::Join("," ,$failedToConvertList))`r`n`t`tAddress this as soon as possible, as this app pool might not be working properly."
        } else {
            Write-Verbose "Mitigation applied for CVE-2022-41040"
        }

        if ($null -ne $details) {
            $params = @{
                AnalyzedInformation = $AnalyzeResults
                DisplayGroupingKey  = $DisplayGroupingKey
                Name                = "Security Vulnerability"
                Details             = $details
                DisplayWriteType    = "Red"
                DisplayTestingValue = "CVE-2022-41040"
            }
            Add-AnalyzedResultInformation @params
        }
    } else {
        Write-Verbose "Server not vulnerable to CVE-2022-41040"
    }
}
